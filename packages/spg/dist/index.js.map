{"version":3,"file":"index.js","sources":["../src/request.ts","../src/transform/length.ts","../src/shall.ts","../src/transform/leet.ts","../src/transform/random.ts","../src/transform/symbols.ts","../src/generator.ts","../src/index.ts","../src/password.ts","../src/transform/normalize.ts","../src/transform/case.ts"],"sourcesContent":["import unfetch from 'unfetch'\nimport { decode } from 'ent'\n\nconst RX_HTML_TAGS = /<\\/?[^>]+(>|$)/g\nconst RX_BASIC_ASCII = /[^\\x20-\\xFF]/g\nconst WIKI_ROOT = 'https://en.wikipedia.org/w/api.php?action=query'\nconst WIKI_RANDOM_PATH = [\n  'generator=random',\n  'grnnamespace=0',\n  'prop=extracts',\n  'exchars=500',\n  'format=json',\n  'origin=*',\n].join('&')\n\ntype WikipediaQuery = {\n  query: {\n    pages: {\n      [id: string]: {\n        extract: string\n      }\n    }\n  }\n}\n\n/**\n * Transform the response's chunks into a JSON and then\n * strip the HTML tags, HTML entities (decode) and non-basic-ascii\n * code (accents allowed) from the payload's extract attr.\n */\nconst parse = (payload: WikipediaQuery) => {\n  const { pages } = payload.query\n  const { extract } = pages[Object.keys(pages)[0]]\n\n  return decode(extract.replace(RX_HTML_TAGS, '').replace(RX_BASIC_ASCII, ''))\n}\n\nexport default async function request() {\n  const response = await unfetch(`${WIKI_ROOT}&${WIKI_RANDOM_PATH}`)\n  if (response.status >= 400) {\n    new Error(\n      `Request failed. Code: ${response.status}. Text: ${response.statusText}`,\n    )\n  }\n\n  const payload = await response.json()\n\n  return parse(payload)\n}\n","const DEFAULT_WORD_MAP = [0, 0]\n\n/**\n * Given a desired length break the sentence with the minimum required words.\n */\nexport default (length: number) => {\n  return function transformLength(base: string) {\n    const words = base.split(' ')\n    const breakingWord = words\n      .map<[string, number]>((word) => [word, word.length])\n      .reduce((memo, [word, wordLength]) => {\n        const lastWordMap = memo[memo.length - 1] || DEFAULT_WORD_MAP\n        return memo.concat([[word, wordLength + lastWordMap[1]]])\n      }, [])\n      .filter(([_, stack]) => stack < length).length\n\n    return words.slice(0, breakingWord + 1).join(' ')\n  }\n}\n","const MAX = 100\nconst DEFAULT_RATIO = MAX / 2\n\n/**\n * Given a probabilistic ratio match against a random number to get a true/false.\n * Default value is half the max (50); simulating a flipping coin.\n */\nconst shall = (ratio = DEFAULT_RATIO) => {\n  return Math.random() * MAX < Math.min(ratio, MAX)\n}\n\n/**\n * Expose 4 common probabilistic types. For 10%, 25%, 50%, 75% and 90%\n */\nexport const weird = () => shall(10)\nexport const low = () => shall(25)\nexport const regular = () => shall()\nexport const high = () => shall(75)\nexport const common = () => shall(90)\n","import * as shall from '../shall'\n\nconst LEET_DICT = {\n  a: 4,\n  b: 8,\n  e: 3,\n  g: 9,\n  l: 1,\n  o: 0,\n  s: 5,\n  t: 7,\n  z: 2,\n}\n\n/**\n * Randomly replace some char by the leet equivalent if any.\n */\nexport default () => {\n  return function transformLeet(base: string) {\n    return base\n      .split('')\n      .map((char) => [char, LEET_DICT[char.toLowerCase()]])\n      .map(([char, leet]) => (leet && shall.weird() ? leet : char))\n      .join('')\n  }\n}\n","import random from 'lodash.random'\nimport * as shall from '../shall'\n\nconst ASCII_LOWER = 37\nconst ASCII_HIGHER = 126\nconst EMPTY_CHAR = ''\n\nconst addRandomChar = () => {\n  if (shall.common()) return EMPTY_CHAR\n  return String.fromCharCode(random(ASCII_LOWER, ASCII_HIGHER))\n}\n\n/**\n * Randomly add some ASCII safe chars either at the beginning, the end or both\n * sides of each word.\n */\nexport default () => {\n  return function transformRandom(base: string) {\n    return base\n      .split(' ')\n      .map((word) => `${addRandomChar()}${word}${addRandomChar()}`)\n      .join(' ')\n  }\n}\n","import random from 'lodash.random'\nimport * as shall from '../shall'\n\nconst DEFAULT_SYMBOL = '.'\nconst SYMBOLS = `@#$%{}[]()/~,;:><${DEFAULT_SYMBOL}`.split('')\nconst EMPTY_CHAR = ''\nconst RX_WHITE_SPACE = / /g\n\n/**\n * Replace white spaces either by a random symbol or an empty char (remove).\n * Note that this transformer gets rid of the white spaces. Hence has to be\n * the last one always.\n * If it's disabled always return the DEFAULT_SYMBOL\n */\nexport default (isEnabled: boolean) => {\n  return function transformSymbols(base: string) {\n    return base.replace(RX_WHITE_SPACE, () => {\n      if (!isEnabled) return DEFAULT_SYMBOL\n\n      return shall.regular() ? SYMBOLS[random(SYMBOLS.length - 1)] : EMPTY_CHAR\n    })\n  }\n}\n","import random from 'lodash.random'\nimport isNumber from 'lodash.isnumber'\nimport identity from 'lodash.identity'\nimport * as password from './password'\nimport transformNormalize from './transform/normalize'\nimport transformLength from './transform/length'\nimport transformLeet from './transform/leet'\nimport transformCase from './transform/case'\nimport transformRandom from './transform/random'\nimport transformSymbols from './transform/symbols'\n\nconst DEFAULT_SENTENCES = [''] // allows init of all methods\nconst DEFAULT_ARGS = {\n  case: false,\n  length: 24,\n  leet: false,\n  random: false,\n  symbols: false,\n}\ntype Args = number | typeof DEFAULT_ARGS\n\nconst sanitizeOptions = (args: Args = {} as Args): typeof DEFAULT_ARGS => {\n  return {\n    ...DEFAULT_ARGS,\n    ...(isNumber(args) ? { length: args } : args),\n  }\n}\n\nexport default function createGenerator(sentences = DEFAULT_SENTENCES) {\n  const maxLength = password.getMaxLength(sentences)\n\n  return function generator(args?: Args) {\n    const options = sanitizeOptions(args)\n    const length = password.getLength(options.length, maxLength)\n    const data = sentences.filter((x) => x.length >= length)\n    const base = data[random(data.length - 1)]\n\n    if (!base) return null\n\n    return [\n      transformNormalize(),\n      transformLength(length),\n      options.leet && transformLeet(),\n      options.case && transformCase(),\n      options.random && transformRandom(),\n      transformSymbols(options.symbols),\n    ]\n      .map((fn) => fn || identity)\n      .reduce((memo, fn) => fn(memo), base)\n  }\n}\n","import nlp from 'compromise'\nimport request from './request'\nimport generator from './generator'\n\nexport default async function spg() {\n  const article = await request()\n  const doc = nlp(article)\n  const sentences = doc.sentences().out('array')\n\n  return generator(sentences)\n}\n","const MIN_PASSWORD_LENGTH = 8\n\nexport const getMaxLength = (sentences: string[]) => {\n  return sentences.reduce((memo, { length }) => {\n    return length > memo ? length : memo\n  }, Number.MIN_SAFE_INTEGER)\n}\n\nexport const getMinLength = (inputLength: number) => {\n  return Math.max(inputLength, MIN_PASSWORD_LENGTH)\n}\n\nexport const getLength = (inputLength: number, maxLength: number) => {\n  return Math.min(getMinLength(inputLength), maxLength)\n}\n","import nlp from 'compromise'\n\n/**\n * Remove non latin chars, etc. That'll cause problems with non-specific\n * keyboard layouts.\n */\nexport default () => {\n  return function transformNormalize(base: string): string {\n    // @ts-ignore The compromise normalize() signature is not correct on @types\n    return nlp(base).normalize().out()\n  }\n}\n","import * as shall from '../shall'\n\n/**\n * Randomly transform to upper case some chars. It assumes that most\n * of the base chars are lower case.\n */\nexport default () => {\n  return function transformCase(base: string) {\n    return base\n      .split('')\n      .map((char) => (shall.low() ? char.toUpperCase() : char))\n      .join('')\n  }\n}\n"],"names":["RX_HTML_TAGS","RX_BASIC_ASCII","WIKI_RANDOM_PATH","join","parse","payload","pages","query","extract","Object","keys","decode","replace","DEFAULT_WORD_MAP","length","base","words","split","breakingWord","map","word","reduce","memo","wordLength","concat","filter","_","stack","slice","shall","ratio","MAX","Math","random","min","LEET_DICT","a","b","e","g","l","o","s","t","z","addRandomChar","String","fromCharCode","SYMBOLS","RX_WHITE_SPACE","DEFAULT_SENTENCES","DEFAULT_ARGS","case","leet","symbols","unfetch","response","status","Error","statusText","json","request","article","sentences","maxLength","Number","MIN_SAFE_INTEGER","password","args","options","isNumber","sanitizeOptions","inputLength","max","getMinLength","data","x","nlp","normalize","out","transformLength","char","toLowerCase","toUpperCase","isEnabled","fn","identity","generator"],"mappings":"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"}